## React useEvent hook剖析

### 来源:

useEvent的来源可以参考react/rfcs这个仓库，这个仓库通过提出议案和讨论，最终会生成react的官方解决方案。



在react/rfcs这个仓库，有一些关于useEvent的提案，可以先进行粗略的阅读，了解这个提案的目的：



https://github.com/facebook/react/issues/14099  

useCallkback，需要对函数进行缓存优化时，可能需要增加依赖项，依赖项的写入可能会导致缓存优化失败。（相当于useCallback的写法不如直接写事件）



https://github.com/reactjs/rfcs/pull/220

useEvent提供了一个对react事件处理的解决方式，经过useEvent包装的事件，既能让事件获取的state/props保持最新，也让整个被包装的事件能保持单独的引用，避免诸如useEffect传入依赖项反复触发，或者传给子组件造成re-render的问题。



如何实现useEvent?

可以根据描述去倒推这个hook如何实现。

首先，使用useEvent包装后的函数，引用不变。

我们可以断定使用了useEffect去监听事件引用是否变化，变化时使用useRef去更新事件。其次返回一个使用useCallback依赖项为空数组包装的函数，该函数返回事件调用参数的结果。

大致以这样的结构去实现：

```
import {useRef,useCallback} from 'react';

// 思路
export function useEvent(handler) {
    // 监听handler事件的引用变动
    const handlerRef = useRef(handler);

    
    useEffect(() => {
        handlerRef.current = handler;
    },[handler])

    // 确保handler调用时引用一致，且能获取到最新的参数
    return useCallback((...args) => {
        return handler.current(...args)
    },[]) 
}


```



更正：应该使用useLayoutEffect去处理事件，这样比useEffect更早